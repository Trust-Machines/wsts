\documentclass{article}
\title{Weighted Threshold FROST}
\date{2023-01-19}
\author{Joey Yandle}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[symbol]{footmisc}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand\underoverset[3]{\underset{#1}{\overset{#2}{#3}}}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\makeatletter
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\Huge\bfseries\@title \par}%
    \vskip 1.5em%
    {\large
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author \footnote{xoloki@gmail.com}
      \end{tabular}\par}%
    \vskip 1em%
    {\large \@date}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

\begin{document}
\onecolumn
\maketitle

\begingroup
\leftskip5em
\parskip1em
\rightskip\leftskip
\noindent\textbf{Abstract.} We present Weighted Threshold FROST (WTF), which optimizes the base FROST implementation to reduce bandwidth when FROST parties control multiple keys.

\par
\noindent\textbf{Keywords:} Weighted Aggregate Threshold Signatures; FROST
\par
\endgroup

\section{
  Introduction
}

FROST (\emph{Flexible Round-Optimized Schnorr Threshold}) \cite{frost} is a system for making aggregate threshold signatures.  This allows a set of $parties$ to construct a group key, and then sign messages using this key as long as a $threshold$ subset cooperates to form the signature.  This signature is aggregated, so that its size does not depend on the number of signing parties.

The design of FROST assumes that each $party$ controls exactly one key, i.e. the $threshold$ is not weighted.  The naive approach to turning FROST into a weighted threshold scheme involves allowing each $signer$ to control a subset of the $parties$ proportional to its weight.  But this results in inefficiencies in the number of messages required for the protocol, and consequently the total bandwidth.

Here we present optimizations on top of vanilla FROST which reduce these inefficiencies when used as a weighted threshold scheme.  We call this scheme WTF (\emph{Weighted Threshold FROST}).

\subsection{
  Notation
}

While WTF can be implemented in any group, we will use curve point terminology exclusively.  This will hopefully make it more accessible to engineers wishing to implement it.

Let $G$ be a generator in an elliptic curve group $\mathbb{G}$.  Let $f$ be a polynomial of a scalar variable with scalar coefficients, and $P$ be a scalar polynomial with curve point coefficients.  Both $f$ and $P$ can be evaluated at a scalar, though the latter will use scalar/point multiplication rather than scalar/scalar.

\newpage
\onecolumn
\section{
  Background
}

\subsection{
  Threshold Signatures
}

Threshold signatures allow a subset of a group of $N$ signers to collaborate to sign messages.  There are many such protocols, but they all specify a threshold $T$, which is the number of signers necessary to create a valid signature.  

\subsection{
  Aggregate Signatures
}

Traditional approaches to the multisignature problem require that each signer signs separately, which means that the size of the signature grows linearly with the number of required signers.  An aggregate scheme, conversely, condenses these individual signatures into a single group signature.  This allows a large set of signers without increasing the data size necessary to transmit and store the signature.

In a blockchain context, where transaction fees are proportional to the size of the data, this leads to significant savings.  It also prevents the case where a large group signature would exceed the blocksize, thereby artificially limiting the number of signers.

\subsection{
  Aggregate Threshold Signatures
}

By combining the concepts of aggregate and threshold signatures, we arrive at a construction well suited to a blockchain context.  We can have any number of possible signers, and any threshold required to make a valid signature.  This allows signatures which can be used in many more contexts than a traditional multisig construct, while keeping transaction fees low and taking no more blockchain space than a standard single signature.

\subsection{
  Weighted Aggregate Threshold Signatures
}

Aggregate threshold signatures function well in a blockchain context, but the number of messages and associated protocol bandwidth required grows linearly with the total number of parties.  In many use cases, though, not all signers should be given the same weight.  This is particularly relevant to Proof of Stake blockchain systems, where the size of a user's stake gives their vote more weight.

It would be ideal to construct a native weighted threshold scheme, where this size would instead grow proportionally to the number of actual signers, rather than the total number of votes.  

\subsection{
  Polynomial Interpolation
}

Consider a polynomial of degree $k$:
\begin{align}
  p_k(x) = a_0 + a_1 x + a_2 x^2 + ... + a_k x^k
\end{align}

There are $k+1$ coefficients needed to form a polynomial of degree $k$.  Thus in order to uniquely determine a polynomial of degree $k$, we will need to evaluate it at $k+1$ points, giving us a system of $k+1$ equations in $k+1$ unknowns.  Typically, we evaluate at the points $[1, k+1]$.  Using these evaluations to determine the coefficients is called Polynomial Interpolation.

To illustrate this, consider the case of a polynomial of degree $k = 1$:
\begin{align}
  p(x) = a_0 + a_1 x\nonumber
\end{align}

In order to uniquely determine this polynomial, we will need to ealuate it at $k+1 = 2$ points:
\begin{align}
  p(1) &= a_0 + a_1\nonumber\\
  p(2) &= a_0 + 2 a_1\nonumber
\end{align}

This gives a system of $2$ equations in $2$ unknowns.  Using the technique of linear combination, if we subtract the first equation from the second we can immediately determine one of the coefficients, then use substitution to get the other:
\begin{align}
  a_1 &= p(2) - p(1)\nonumber\\
  a_0 &= p(1) - (p(2) - p(1))\nonumber\\
      &= 2 \cdot p(1) - p(2)\nonumber
\end{align}

\newpage
\onecolumn
\subsection{
  FROST
}

FROST is an aggregate threshold signing scheme.  It allows for a group of $N$ parties to create a group signing key trustlessly.  Then some threshold $T$ of them can cooperate to form a group signature, which is an aggregate of each individual signature.

Thus there are three discrete elements required: distributed key generation, gathering party signatures, and forming an aggregate group signature using the party signatures.

\subsection{
  Distributed Key Generation (DKG)
}

Like many DKG schemes, FROST employs the technique of polynomial interpolation.  But whereas traditional DKG protocols use a trusted dealer, FROST is a trustless protocol.  To accomplish this, each party acts as a trusted dealer to every other party, and runs a traditional DKG protocol.  The parties then combine their keys trustlessly, and the result is a fully trustless distributed key, of which each party controls an equal share.

Remember that in polynomial interpolation, you need $k+1$ points to interpolate a degree $k$ polynomial.  FROST specifies a threshold $T$, which is the number of signers necessary to sign a message.  Thus we will need a polynomial of degree $T-1$ so that any group of $T$ signers will be able to interpolate the key, and thereby sign.

First, each party is given a sequential ID $i \in [1, N]$, which will be used both to identify it and as an element in the underlying math.  Next, each party constructs a random private polynomial $f$ of degree $T-1$, where the coefficients are scalars.  A public DKG share is constructed from $f$ by multiplying each coefficient by a generator $G$.  The ID and public polynomial $P$ is then shared to all other parties.

The parties then evaluate their own $f$ at each $i \in [1,N]$, and send a private DKG share to each consisting of $(i, f(i))$.  Each receiving party checks each private share for consistency with the public polynomial of the sending party.  This is done by checking that
\begin{align}
  f_i(j) * G = P_i(j)
\end{align}

Once the private shares are verified, each party computes its share $s_i$ of the group secret key by summing the private polynomial evaluations from all the other parties:
\begin{align}
  s_i = \sum_{j=1; j \neq i}^{N} f_j(i)
\end{align}

Each party computes the group public key $K$ by summing the first coefficient of each public polynomial:
\begin{align}
  K = \sum_{j=1}^{N} P_j(0)
\end{align}

At this point DKG is complete, and each party $i$ knows $s_i, K$.

\subsection{
  Gathering Party Signatures
}

In order for polynomial interpolation to work, it is necessary to choose the siging set $S$ before any party can sign, with $|S| >= T$.

\subsection{
  Aggregating the Group Signature
}


\newpage
\onecolumn
\section{
  Related Work
}


\newpage
\onecolumn
\section{
  WTF
}


\newpage
\onecolumn
\begin{thebibliography}{1}

\bibitem{frost}
  Chelsea Komlo, Ian Goldberg
  \emph{FROST: Flexible Round-Optimized Schnorr Threshold Signatures} 2020.12.22.
  \texttt{https://eprint.iacr.org/2020/852.pdf}

\end{thebibliography}

\end{document}

