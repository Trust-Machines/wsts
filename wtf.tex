\documentclass{article}
\title{Weighted Threshold FROST}
\date{2023-01-19}
\author{Joey Yandle}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[symbol]{footmisc}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand\underoverset[3]{\underset{#1}{\overset{#2}{#3}}}

\usepackage{geometry}
\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\makeatletter
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\Huge\bfseries\@title \par}%
    \vskip 1.5em%
    {\large
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author \footnote{xoloki@gmail.com}
      \end{tabular}\par}%
    \vskip 1em%
    {\large \@date}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

\begin{document}
\onecolumn
\maketitle

\begingroup
\leftskip5em
\parskip1em
\rightskip\leftskip
\noindent\textbf{Abstract.} We present Weighted Threshold FROST (WTF), which optimizes the base FROST implementation to reduce bandwidth when FROST parties control multiple keys.

\par
\noindent\textbf{Keywords:} Weighted Aggregate Threshold Signatures; Zero-Knowledge Proofs; FROST
\par
\endgroup

\section{
  Introduction
}

FROST \emph{(Flexible Round-Optimized Schnorr Threshold)} \cite{frost} is a system for making aggregate threshold signatures.  This allows a set of $parties$ to construct a group key, and then sign messages using this key as long as a $threshold$ subset cooperates to form the signature.  This signature is aggregated, so that its size does not depend on the number of signing parties.

The design of FROST assumes that each $party$ controls exactly one key, i.e. the $threshold$ is not weighted.  The naive approach to turning FROST into a weighted threshold scheme involves allowing each $signer$ to control a subset of the $parties$ proportional to its weight.  But this results in inefficiencies in the number of messages required for the protocol, and consequently the total bandwidth.

Here we present optimizations on top of vanilla FROST which reduce these inefficiencies when used as a weighted threshold scheme.  We call this scheme WTF \emph{(Weighted Threshold FROST)}.

\subsection{
  Notation
}

While WTF can be implemented in any group, we will use curve point terminology exclusively.  This will hopefully make it more accessible to engineers wishing to implement it.

Let $G$ be a generator in an elliptic curve group $\mathbb{G}$.  Let $f$ be a polynomial of a scalar variable with scalar coefficients, and $P$ be a scalar polynomial with curve point coefficients.  Both $f$ and $P$ can be evaluated at a scalar, though the latter will use scalar/point multiplication rather than scalar/scalar.

\newpage
\onecolumn
\section{
  Background
}

\subsection{
  Threshold Signatures
}

Threshold signatures allow a subset of a group of $N$ signers to collaborate to sign messages.  There are many such protocols, but they all specify a threshold $T$, which is the number of signers necessary to create a valid signature.  

\subsection{
  Aggregate Signatures
}

Traditional approaches to the multisignature problem require that each signer signs separately, which means that the size of the signature grows linearly with the number of required signers.  An aggregate scheme, conversely, condenses these individual signatures into a single group signature.  This allows a large set of signers without increasing the data size necessary to transmit and store the signature.

In a blockchain context, where transaction fees are proportional to the size of the data, this leads to significant savings.  It also prevents the case where a large group signature would exceed the blocksize, thereby artificially limiting the number of signers.

\subsection{
  Aggregate Threshold Signatures
}

By combining the concepts of aggregate and threshold signatures, we arrive at a construction well suited to a blockchain context.  We can have any number of possible signers, and any threshold required to make a valid signature.  This allows signatures which can be used in many more contexts than a traditional multisig construct, while keeping transaction fees low and taking no more blockchain space than a standard single signature.

\subsection{
  Weighted Aggregate Threshold Signatures
}

Aggregate threshold signatures function well in a blockchain context, but the number of messages and associated protocol bandwidth required grows linearly with the total number of parties.  In many use cases, though, not all signers should be given the same weight.  This is particularly relevant to Proof of Stake blockchain systems, where the size of a user's stake gives their vote more weight.

It would be ideal to construct a native weighted threshold scheme, where this size would instead grow proportionally to the number of actual signers, rather than the total number of votes.  

\subsection{
  Polynomial Interpolation
}

Consider a polynomial of degree $k$:
\begin{align}
  p_k(x) = a_0 + a_1 x + a_2 x^2 + ... + a_k x^k
\end{align}

There are $k+1$ coefficients needed to form a polynomial of degree $k$.  Thus in order to uniquely determine a polynomial of degree $k$, we will need to evaluate it at $k+1$ points, giving us a system of $k+1$ equations in $k+1$ unknowns.  Typically, we evaluate at the points $[1, k+1]$.  Using these evaluations to determine the coefficients is called Polynomial Interpolation.

To illustrate this, consider the case of a polynomial of degree $k = 1$:
\begin{align}
  p(x) = a_0 + a_1 x\nonumber
\end{align}

In order to uniquely determine this polynomial, we will need to ealuate it at $k+1 = 2$ points:
\begin{align}
  p(1) &= a_0 + a_1\nonumber\\
  p(2) &= a_0 + 2 a_1\nonumber
\end{align}

This gives a system of $2$ equations in $2$ unknowns.  Using the technique of linear combination, if we subtract the first equation from the second we can immediately determine one of the coefficients, then use substitution to get the other:
\begin{align}
  a_1 &= p(2) - p(1)\nonumber\\
  a_0 &= p(1) - (p(2) - p(1))\nonumber\\
      &= 2 \cdot p(1) - p(2)\nonumber
\end{align}

\newpage
\onecolumn

\subsection{
  Schnorr Proofs
}

A Schnorr proof \cite{schnorr} is a zero knowledge proof of ownership of a public key.  Let scalar $x$ be a private key, with point $X = x \cdot G$ the corresponding public key.  To prove knowledge of $x$ given $X$, Schnorr proofs use a $3$-move challenge-response protocol, i.e. a Sigma protocol.

The prover first creates a random scalar $v$, and the corresponding point $V$, and sends them to the verifier.  The verifier then returns a random challenge scalar $c$.  The prover then constructs the response $r = v + cx$.  The proof consists of the tuple $(r, c, V)$.

To verify the proof, check that:
\begin{align}
  V = r \cdot G - c \cdot X
\end{align}

This must be true for a valid proof, since:
\begin{align}
  V &= v \cdot G = (r - cx) \cdot G = r \cdot G - cx \cdot G = r \cdot G - c \cdot X\nonumber
\end{align}

To make this protocol non-interactive, use the Fiat-Shamir transform \cite{fiatshamir} to construct $c$ by hashing the initial proof elements $(G, X, V)$:
\begin{align}
  c = H(G, X, V)
\end{align}

\subsection{
  FROST
}

FROST is an aggregate threshold signing scheme.  It allows for a group of $N$ parties to create a distributed group signing key, then some threshold $T$ of them can cooperate to sign a message.  This group signature is an aggregate of the individual party signatures.

Thus there are three discrete elements required: distributed key generation, gathering party signatures, and forming an aggregate group signature using the party signatures.

\subsubsection{
  Distributed Key Generation (DKG)
}

Like many DKG schemes, FROST employs the technique of polynomial interpolation.  But whereas traditional DKG protocols use a trusted dealer, FROST is a trustless protocol.  To accomplish this, each party acts as a trusted dealer to every other party, and runs a traditional DKG protocol.  The parties then combine their keys trustlessly, and the result is a fully trustless distributed key, of which each party controls an equal share.

Remember that in polynomial interpolation, you need $k+1$ points to interpolate a degree $k$ polynomial.  FROST specifies a threshold $T$, which is the number of signers necessary to sign a message.  Thus we will need a polynomial of degree $T-1$ so that any group of $T$ signers will be able to interpolate the key, and thereby sign.

First, each party is given a sequential ID $i \in [1, N]$, which will be used both to identify it and as an element in the underlying math.  Next, each party constructs a random private polynomial $f$ of degree $T-1$, where the coefficients are scalars.  A public DKG share is constructed from $f$ by multiplying each coefficient by a generator $G$.  The ID and public polynomial $P$ is then shared to all other parties.

The parties then evaluate their own $f$ at each $j \in [1,N]$, and send a private DKG share to each consisting of $(j, f_i(j))$.  Each receiving party checks each private share for consistency with the public polynomial of the sending party.  This is done for party $i$ by checking that:
\begin{align}
  \forall j \in [1,N] \ni j \neq i;\;f_j(i) \cdot G = P_j(i)
\end{align}

Once the private shares are verified, each party computes its share $s_i$ of the group secret key by summing the private polynomial evaluations from all the other parties, then uses it to construct its public key $Y_i$:
\begin{align}
  s_i = \sum_{j=1; j \neq i}^{N} f_j(i) ;\; Y_i = s_i \cdot G
\end{align}

Each party computes the group public key $K$ by summing the first coefficient of each public polynomial:
\begin{align}
  Y = \sum_{j=1}^{N} P_j(0)
\end{align}

At this point DKG is complete, and each party $i$ knows $(s_i, Y)$.

\newpage
\onecolumn
\subsubsection{
  Gathering Party Signatures
}

In order for polynomial interpolation to work, it is necessary to choose the siging set $S$ before any party can sign, with $|S| >= T$.  Each party $i \in S$ then constructs a private nonce $(d_i,e_i)$ and corresponding public nonce $(D_i,E_i)$, then sends $(D_i,E_i)$ to all other parties in $S$.

Once nonces have been received, each party $i \in S$ computes the binding values $\rho_j$:
\begin{align}
  \forall j \in S;\;\rho_j = H(j, D_j, E_j)
\end{align}

Next they compute the interpolation value $\lambda_i$:
\begin{align}
  \lambda_i = \prod_{j=1; j \neq i}^{N} \frac{j}{j - i}
\end{align}

Each party also computes the sum $R$:
\begin{align}
  R = \sum_{j=1}^{N} D_j + \rho_j \cdot E_j
\end{align}

Once they have $R$ and message $m$ they can construct the challenge $c$:
\begin{align}
  c = H(Y, R, m)
\end{align}

Finally, each party $i$ can construct its signature share $z_i$:
\begin{align}
  z_i = d_i + \rho_i \cdot e_i + s_i \cdot c \cdot \lambda_i
\end{align}


\subsubsection{
  Aggregating the Group Signature
}

Once the aggregator has gathered the signature shares $z_i$, it must first verify that they are valid by checking that:
\begin{align}
  z_i \cdot G = D_i + \rho_i \cdot E_i + s_i \cdot c \cdot \lambda_i
\end{align}

Finally the aggregator can construct the group signature $z$:
\begin{align}
  z = \sum_{i=1}^{N} z_i
\end{align}

The full signature consists of $(R, z)$ using $R$ from $(10)$.

\subsubsection{
  Verifying the Group Signature
}

To verify the group signature, construct the value $R'$ from the group public key $Y$, challenge $c$, and group signature $z$:
\begin{align}
  R' = z \cdot G - c \cdot Y
\end{align}

If $R = R'$, the proof is valid.

\newpage
\onecolumn
\section{
  Related Work
}

There are many aggregate threshold signature scheme, some quite similar to FROST.  While FROST is optimized for a reduced number of rounds in the optimistic case of no byzantine actors, there are others which are called $robust$; i.e. they take more rounds in the common case, but can complete even if some signers are byzantine actors.

An excellent example of a robust protocol is Provably Secure Distributed Schnorr Signatures (PSDSS) \cite{psdss}.  The construction features robustness in both the DKG and signing rounds.  At both stages, the protocol will succeed as long as at least $T$ parties complete it honestly.

We did not choose PSDSS as the basis for WTF for two reasons.  First, rather than gather nonces from signing parties in each signing round, it runs an additional DKG to create an ephermal round key.  Since DKG is an expensive protocol in the case of a large number of voting slots, it was suboptimal for our use case.  Also, attempts to use the same techniques as were used on FROST to optimize the bandwidth used did not appear to be viable for PSDSS.

There are also many native weighted threshold signing schemes, but ultimately all were rejected.  Most of them relied on RSA with a trusted setup, and so were considered prima facie unsuitable.

There was one compelling candidate though: An Efficient and Secure Weighted Threshold Signcryption Scheme \cite{eswtss}.  It uses standard elliptic curves combined with a dynamic knapsack sytem, and the Chinese Remainder theorem to set the voting weights.  We rejected it due to its complexity and lack of track record in production systems.  But it remains an ongoing object of research.

\newpage
\onecolumn
\section{
  WTF: Weighted Threshold FROST
}


\newpage
\onecolumn
\begin{thebibliography}{5}

\bibitem{frost}
  Chelsea Komlo, Ian Goldberg
  \emph{FROST: Flexible Round-Optimized Schnorr Threshold Signatures} 2020.12.22.
  \texttt{https://eprint.iacr.org/2020/852.pdf}

\bibitem{schnorr}
  \emph{Schnorr signature}.
  \texttt{https://en.wikipedia.org/wiki/Schnorr\%5Fsignature}

\bibitem{fiatshamir}
  \emph{Fiat Shamir heuristic}.
  \texttt{https://en.wikipedia.org/wiki/Fiat\%2DShamir\%5Fheuristic}

\bibitem{psdss}
  D.R. Stinson, R. Strobl
  \emph{Provably Secure Distributed Schnorr Signatures and a (t,n) Threshold Scheme for Implicit Certificates} ACISP 2001. Lecture Notes in Computer Science, vol 2119 2001.01.23.
  \texttt{https://doi.org/10.1007/3-540-47719-5\_33}

\bibitem{eswtss}
  Chien-Hua Tsai
  \emph{An Efficient and Secure Weighted Threshold Signcryption Scheme} Journal of Internet Technology, vol. 20, no. 5 , pp. 1523-1534, Sep. 2019
  \texttt{https://jit.ndhu.edu.tw/article/view/2135}

\end{thebibliography}

\end{document}

